// This file is part of JavaXServ.
// http://SourceForge.Net/p/JavaXServ
// Copyright (C) Keith Sloan 2008-2013 keith@sloan-home.co.uk
//
// JavaXServ is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License
// as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
// JavaXServ is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with JavaXServ.  If not, see <http://www.gnu.org/licenses/>.
  

#include <iostream>
#include <cstring>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
// #include "tcpSocket.h"
#include "Xwindow.h"
#include "GraphicContext.h"
#include "ColourMap.h"
#include "stdio.h"
#include "stdlib.h"
#include "time.h"

extern "C"              // C includes
{
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <signal.h>
#define NEED_REPLIES
#define NEED_EVENTS
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include <X11/Xlib.h>
#include <errno.h>
}
//--------------------------------------//
// Constants
//--------------------------------------//
#define PORT        6789
#define MAXFONTS      64
#define MAXFONTNAME  256
#define STACKSIZE   1024
#define FIRSTKEY       9
#define TIMEOUT	     600
#define MAXREQUESTSIZE 8192
#define COLOURMAPSIZE 256
#define X11SESSIONS   4

#define DEBUG

#include "keymap.C"

//--------------------------------------//
// Externals
//--------------------------------------//
extern int errno;
extern char **environ;
//--------------------------------------//
// Globals
//--------------------------------------//
char      byteOrder;
int       setupPid1;
int       setupPid2;
int       sequenceNum = 0;
tcpSocket* X11Serv;			// Main X11 Server socket
tcpSocket* javaServ;			// Main Java Server Socket
tcpSocket* X11sock[X11SESSIONS];
Xwindow   *rootWin;
GraphicContext *rootGC;
ColourMap *rootColourMap = new ColourMap(0x20);
// = new GC(0,0);
//--------------------------------------//
// Declare static variables             //
//--------------------------------------//
Xwindow*   Xwindow::last = rootWin;
int        Xwindow::nextJavaWin = 1;
tcpSocket* Xwindow::javasock = NULL;	// Socket to listen for Jave Clients
//tcpSocket* Xwindow::X11sock  = NULL;	// Socket to Listen for X Clients
Display*   Xwindow::display;
//--------------------------------------//
// Globals for X calls & related
//--------------------------------------//

char    *displayVariable;
struct
   {
   int   fid;
   Font  font;
   int   pointSize;
   } fontTable[MAXFONTS];
int fontEntries;

XFontStruct *fontFix;
//--------------------------------------//

void dumpHex(char *ptr,int len)
{
int i;
	
for(i=0; i < len; i++)
   {
   ::printf("%02x",*ptr++);
   }
::printf("\n");
}

void printHex(int value)
{
::printf("0x%08x\n",value);
}

void sendReplyHdr(tcpSocket *sockPtr,int words )
{
struct
  {
  char type;
  char data;
  CARD16 sequenceNumber;
  CARD32 length;
  } reply;

reply.type = 1;
reply.data = 0;
reply.sequenceNumber = sequenceNum;
reply.length = words - 8;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
}

void connectionSetup(tcpSocket *sockPtr)
{

//#define Col8bit TRUE

xConnClientPrefix clientPrefix;
char protocol[256];
char auth[256];

struct __attribute__((__packed__))
  {
  xConnSetupPrefix hdr;
  xConnSetup       setup;
  char             vendor[32];
  xPixmapFormat    format1;
#ifdef Col8bit
  xPixmapFormat    format8;
#endif
  xPixmapFormat    format24;
  xWindowRoot      window;
  xDepth           depth1;
#ifdef Col8bit
  xDepth           depth8;
  xVisualType      visual8;
#endif
  xDepth	depth24;
  xVisualType	visual24;
  } reply;

std::cerr << "Connection Setup Read"<< std::endl;
//Xwindow::X11sock -> read((char *) &clientPrefix,sizeof(xConnClientPrefix));
sockPtr -> read((char *) &clientPrefix,sizeof(xConnClientPrefix));
byteOrder = clientPrefix.byteOrder;
std::cerr << "Byte Order of Client : " << byteOrder << std::endl;
std::cerr << "Major Version : " << clientPrefix.majorVersion << std::endl;
std::cerr << "Minor Version : " << clientPrefix.minorVersion << std::endl;
std::cerr << "Auth Protocol string len : " << clientPrefix.nbytesAuthProto << std::endl;
if (clientPrefix.nbytesAuthProto > 0 )
   {
   std::memset(&protocol,0,256);
   //Xwindow::X11sock -> read((char *) &protocol,clientPrefix.nbytesAuthProto+1);
   sockPtr -> read((char *) &protocol,clientPrefix.nbytesAuthProto+1);
   std::cerr << "Auth Protocol : " << protocol << std::endl;
   }
std::cerr << "Auth String Len : " << clientPrefix.nbytesAuthString << std::endl;
if (clientPrefix.nbytesAuthString > 0 )
   {
   std::memset(&auth,0,256);
   //Xwindow::X11sock -> read((char *) &auth,clientPrefix.nbytesAuthString+1);
   sockPtr -> read((char *) &auth,clientPrefix.nbytesAuthString+1);
   std::cerr << "Auth String : " << auth << std::endl;
   }
// Think I need to set byteorder on X11 socket

std::memset(&reply,0,sizeof(reply));
reply.hdr.success = TRUE;
reply.hdr.majorVersion = 11;
reply.hdr.minorVersion = 0;

//reply.hdr.length = 40;
reply.hdr.length = (sizeof(reply) - 8) >> 2;
std::cerr << " Header Length : " << reply.hdr.length  << std::endl;
reply.setup.release = 11;
reply.setup.ridBase = 0x05000000;
reply.setup.ridMask = 0x003FFFFF;
reply.setup.nbytesVendor = 0x1E;
reply.setup.maxRequestSize = MAXREQUESTSIZE;	// maxRequestSize in bytes is this value * 4
reply.setup.numRoots = 1;
#ifdef Col8bit
reply.setup.numFormats = 3;
#else
reply.setup.numFormats = 2;
#endif
reply.setup.imageByteOrder = MSBFirst;
reply.setup.bitmapBitOrder = MSBFirst;
reply.setup.bitmapScanlineUnit = 32;
reply.setup.bitmapScanlinePad = 32;
reply.setup.minKeyCode = FIRSTKEY;
reply.setup.maxKeyCode = 141;
reply.setup.pad2 = 0;
strcpy(reply.vendor,"JavaXServ");
reply.format1.depth = 1;
reply.format1.bitsPerPixel = 1;
reply.format1.scanLinePad = 8;          // Trace is in hex

#ifdef Col8bit
   reply.format8.depth = 8;
   reply.format8.bitsPerPixel = 8;
   reply.format8.scanLinePad  = 8;
#endif

reply.format24.depth = 24;
reply.format24.bitsPerPixel = 32;
reply.format24.scanLinePad  = 32;
reply.window.windowId = rootWin -> X11windowId();
// display is a global variable
reply.window.defaultColormap = rootWin -> getColourMap(); 
reply.window.whitePixel = 0x00FFFFFF;
reply.window.currentInputMask = 0x4180003F;
reply.window.pixWidth = 600;
reply.window.pixHeight = 800;
reply.window.mmWidth = 156;
reply.window.mmHeight = 112;
reply.window.minInstalledMaps = 1;
reply.window.maxInstalledMaps = 1;
reply.window.rootVisualID = 0x21;
reply.window.rootDepth = 24;
#ifdef Col8bit
reply.window.nDepths = 3;
#else
reply.window.nDepths = 2;
#endif
reply.depth1.depth = 1;
reply.depth1.nVisuals = 0;

#ifdef Col8bit
   reply.depth8.depth = 8;
   reply.depth8.nVisuals = 1;
   reply.visual8.visualID = 0x21;
   reply.visual8.c_class = PseudoColor;  // Need to support 8 bit Pseudocolour for Old Applications
   reply.visual8.bitsPerRGB = 8;
   reply.visual8.colormapEntries = 512;
   reply.visual8.redMask = 0xFF0000;
   reply.visual8.greenMask = 0xFF00;
   reply.visual8.blueMask = 0xFF;
#endif

reply.depth24.depth = 24;
reply.depth24.nVisuals = 1;
reply.visual24.visualID = 0x21;
reply.visual24.c_class = DirectColor;  
reply.visual24.bitsPerRGB = 8;
reply.visual24.colormapEntries = 512;
reply.visual24.redMask = 0xFF0000;
reply.visual24.greenMask = 0xFF00;
reply.visual24.blueMask = 0xFF;

// Need to add support for 24bit true colour for new applications
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
std::cerr << "Reply Authorized" << std::endl;
}

void internAtom(tcpSocket *sockPtr,xInternAtomReq *ptr)
{
xInternAtomReply reply;
char *namePtr= ((char *) ptr) + sizeof(xInternAtomReq);
char name[120];

::memcpy(name,namePtr,ptr -> nbytes);
name[ptr -> nbytes] = '\0';

std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
std::cerr << "Reply sequence Number : " << sequenceNum << std::endl;
reply.atom = XInternAtom(Xwindow::display,name, ptr -> onlyIfExists);
std::cerr << "InternAtom : " << name << " Value : " << reply.atom << std::endl;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
}

void getAtomName(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetAtomNameReply reply;
char *namePtr;
int len;

std::cerr << "getAtomName" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
namePtr = XGetAtomName(Xwindow::display,ptr -> id);
len     = strlen(namePtr);
reply.length = (len + 3) >> 2;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
//Xwindow::X11sock -> write(namePtr,(reply.length << 2));
sockPtr -> write(namePtr,(reply.length << 2));
}

void replyNoProperty(tcpSocket *sockPtr)
{
xGetPropertyReply reply;

std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.format = 0;
reply.sequenceNumber = sequenceNum;
reply.length = 0;
reply.propertyType = 0;
reply.bytesAfter = 0;
reply.nItems = 0;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
}

//
// Need to change this to support property properly
// Making XGetWindowPropert on javaServ DISPLAY will
// get found out with some applications
//
void getProperty(tcpSocket *sockPtr,xGetPropertyReq *ptr)
{
Atom actual;
unsigned long items,bytes;
unsigned char *prop;
int format,ret,len;

xGetPropertyReply reply;

std::cerr << "GetProperty - Window : " << ptr -> window << " Property : " << ptr -> property << " type " << ptr -> type << std::endl;
std::cerr << "Long offset : " << ptr -> longOffset << " Long Length : " << ptr -> longLength << std::endl;
std::cerr << "property : " << XGetAtomName(Xwindow::display,ptr -> property) << std::endl;
if ( ptr -> window == rootWin -> X11windowId())
   {
   std::cerr << "Root window XGetWindowProperty : " << std::endl;
   ret = XGetWindowProperty(Xwindow::display,ptr -> window,ptr -> property,
         ptr -> longOffset, ptr -> longLength,ptr -> c_delete,
         ptr -> type,&actual,&format,&items,&bytes,&prop);
   if ( ret != 0 )
      {
      std::cerr << "XGetWindowProperty failed : " << ret << std::endl;
      }
   else
      {
      // Okay success now need to Free
      std::cerr << "Xfree " << std::endl; 
      XFree(prop);
      }
   if ( bytes > 0 )
      std::cerr << "Only Partial Read of Property need to code for" << std::endl;

  std::cerr << "actual : " << actual << " format : " << format << " items : " << items << std::endl;
  std::cerr << "bytes : " << bytes << " prop :  " << prop << std::endl;
  }
else
  {
  std::cerr << "Non Root Window " << std::endl;
  actual = 0;
  items = format = 0;
  bytes = 0;
  }
std::cerr << "Send Reply to GetProperty" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.format = format;
reply.sequenceNumber = sequenceNum;
std::cerr << "Sequence Number : " << sequenceNum << std::endl;
switch ( format )
   {
   case 0  :
        reply.length = 0;
        break;

   case 8  :
        reply.length = (items + 3) >> 2;
        len = items + bytes;
        break;

   case 16 :
        reply.length = (items + 1) >> 1;
        len = (items << 1) + bytes;
        break;

   case 32 :
        reply.length = items;
        len = (items << 2) + bytes;
        break;

   default :
        std::cerr << "Type not yet coded for : guess bytes" << std::endl;
        reply.length = (items + 3) >> 2;
        len = items + bytes;
        break;
   }
reply.propertyType = actual;
reply.bytesAfter = bytes;
reply.nItems = items;
// dumpHex((char *) &reply,32);
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
if ( actual != 0 )
   {  
   //Xwindow::X11sock -> write((char *) prop,len);
   sockPtr -> write((char *) prop,len);
   //Xwindow::X11sock -> write("    ",(reply.length << 2) - len);
   sockPtr -> write("    ",(reply.length << 2) - len);
   }
// Call XFree to free results ?
}

int fontPointSize(char *str)
{
// Don't seem to be able to use sscanf for this
int l = strlen(str);
int i,j,ps;

i = j = 0;
while ( j < 8 && i < l)
   {
   if (*str == '-' ) j++;
   str++;
   i++;
   }
if ( ::sscanf(str,"%n-",&ps) != 1 )
   {
   std::cerr << "Error with Font Point size" << std::endl;
   }
std::cerr << "Point size : " << ps << std::endl;
return(ps);
}

void queryFont(tcpSocket *sockPtr,xResourceReq *ptr)
{
XFontStruct *fontStr;
xQueryFontReply reply;
int i;

std::cerr << "New Query Font fid : " << ptr -> id;
// Find font in our table
i = 0;
while ( i < fontEntries && fontTable[i].fid != ptr -> id)
   {
   i++;
   }
if ( i == fontEntries )
   {
   std::cerr << "fid " << ptr -> id << " Not in our Table" << std::endl;
   exit(1);
   }
std::cerr << " FONT " << fontTable[i].font << std::endl;
if ((fontStr = ::XQueryFont(Xwindow::display,fontTable[i].font)) == NULL )
   {
   std::cerr << "Font not found" << std::endl;
   exit(1);
   }
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.pad1 = 0;
reply.sequenceNumber = sequenceNum;
::memcpy(&reply.minBounds,&(fontStr -> min_bounds),12);
::memcpy(&reply.maxBounds,&(fontStr -> max_bounds),12);
reply.minCharOrByte2 = fontStr -> min_char_or_byte2;
reply.maxCharOrByte2 = fontStr -> max_char_or_byte2;
reply.defaultChar = fontStr -> default_char;
reply.nFontProps = fontStr -> n_properties;
reply.drawDirection = fontStr -> direction;
reply.minByte1 = fontStr -> min_byte1;
reply.maxByte1 = fontStr -> max_byte1;
reply.allCharsExist = fontStr -> all_chars_exist;
reply.fontAscent = fontStr -> ascent;
reply.fontDescent = fontStr -> descent;
reply.nCharInfos = reply.maxCharOrByte2 - reply.minCharOrByte2 + 1;
std::cerr << "Number of Chars : " << reply.nCharInfos << std::endl;
std::cerr << "Number of properties : " << reply.nFontProps << std::endl;
std::cerr << "Size of reply : " << sizeof(reply) / 4 << std::endl;
reply.length = (sizeof(reply)/4) - 8 + (2 * reply.nFontProps) + ( 3 * reply.nCharInfos); // Length is additional length so minus 8 byte header
std::cerr << "Reply Length : "<< reply.length << std::endl;
//Xwindow::X11sock -> assert();
sockPtr -> assert();
//Xwindow::X11sock -> put((char *) &reply,sizeof(reply));
sockPtr -> put((char *) &reply,sizeof(reply));
//Xwindow::X11sock -> put((char *) fontStr -> properties,8 * reply.nFontProps);
sockPtr -> put((char *) fontStr -> properties,8 * reply.nFontProps);
//Xwindow::X11sock -> put((char *) fontStr -> per_char,12 * reply.nCharInfos);
sockPtr -> put((char *) fontStr -> per_char,12 * reply.nCharInfos);
//Xwindow::X11sock -> flush();
sockPtr -> flush();
// ::XFreeFontInfo(Xwindow::display,fontStr,1);
}


void listFonts(tcpSocket *sockPtr,xListFontsReq *ptr)
{
// Must be multiple of 4 bytes

xListFontsReply reply;
char **listPtr;
char **wrkptr;
char pattern[MAXFONTNAME];
int num;
int i;
int sl;
char cl;

std::cerr << "List Fonts" << std::endl;
if ( strlen((char *) ptr + sizeof(xListFontsReq)) != ptr -> nbytes)
   {
   std::cerr << " Need to copy string" << std::endl;
   }
strncpy(pattern,(char *) ptr + sizeof(xListFontsReq),ptr -> nbytes);
pattern[ptr -> nbytes] = NULL;

listPtr = ::XListFonts(Xwindow::display,pattern,ptr -> maxNames,&num);
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
reply.nFonts = num;
sl = 0;
wrkptr = listPtr;
for ( i=0; i < num; i++)
    {
    sl += strlen(*wrkptr) + 1;  // string preceded by 1 byte length
    wrkptr++;
    }
reply.length = (sl + 3) >> 2;
std::cerr << "Fonts : " << num << " Total String Length " << sl << std::endl;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
wrkptr = listPtr;
for ( i=0; i < num; i++)
    {
    std::cerr << " Font : " << (*wrkptr) << " strlen : " << strlen(*wrkptr);
    cl = (char) strlen(*wrkptr);
    // Xwindow::X11sock -> write(&cl,1);
    sockPtr -> write(&cl,1);
    // Xwindow::X11sock -> write(*wrkptr,strlen(*wrkptr));
    sockPtr -> write(*wrkptr,strlen(*wrkptr));
    wrkptr++;
    }
//Xwindow::X11sock -> write("    ",(reply.length << 2) - sl);
sockPtr -> write("    ",(reply.length << 2) - sl);
::XFreeFontNames(listPtr);
}

void openFont(xOpenFontReq *ptr)
{
char name[MAXFONTNAME];

strncpy(name,(char *) ptr + sizeof(xOpenFontReq),ptr -> nbytes);
name[ptr -> nbytes] = NULL;
std::cerr << "Open Font : " << name << " Fid " << ptr -> fid;

if ( fontEntries < MAXFONTS )
   {
   if ((fontTable[fontEntries].font = ::XLoadFont(Xwindow::display,name)) == NULL )
      {
      std::cerr << "Open Font failed" << std::endl;
      }
   else
      {
      fontTable[fontEntries].pointSize = fontPointSize(name);
      fontTable[fontEntries++].fid     = ptr -> fid;
      }
   }
else
   {
   std::cerr << "Out of Font Table entries" << std::endl;
   }
}

void  listFontsWithInfo(tcpSocket *sockPtr,xListFontsReq *ptr)
{
xListFontsWithInfoReply reply;
XFontStruct *fontPtr;
XFontStruct *wrkptr;
char        **namePtr;
char        pattern[MAXFONTNAME];
int i, num, sl,pl;

std::cerr << "List Fonts with Info" << std::endl;
strncpy(pattern,(char *) ptr + sizeof(xListFontsReq),ptr -> nbytes);
pattern[ptr -> nbytes] = NULL;

std::cerr << pattern << std::endl;

namePtr = ::XListFontsWithInfo(Xwindow::display,pattern,ptr -> maxNames,&num,&fontPtr);
std::memset(&reply,0,sizeof(reply));

std::cerr << "Number : " << num << std::endl;
reply.type = 1;
reply.sequenceNumber = sequenceNum;
wrkptr = fontPtr;
for ( i=0; i < num; i++)
    {
    reply.nameLength = sl = strlen(*namePtr);
    ::memcpy(&reply.minBounds,&(wrkptr -> min_bounds),12);
    ::memcpy(&reply.maxBounds,&(wrkptr -> max_bounds),12);
    reply.minCharOrByte2 = wrkptr -> min_char_or_byte2;
    reply.maxCharOrByte2 = wrkptr -> max_char_or_byte2;
    reply.defaultChar = wrkptr -> default_char;
    reply.nFontProps = wrkptr -> n_properties;
    reply.drawDirection = wrkptr -> direction;
    reply.minByte1 =wrkptr -> min_byte1;
    reply.maxByte1 = wrkptr -> max_byte1;
    reply.allCharsExist = wrkptr -> all_chars_exist;
    reply.fontAscent = wrkptr -> ascent;
    reply.fontDescent = wrkptr -> descent;
    std::cerr << "Number of properties : " << reply.nFontProps << std::endl;
    reply.length = (sizeof(reply) / 4) - 8 + (2 * reply.nFontProps) + ((sl + 3) >> 2); // Additional length i.e minus 8 byte header
    std::cerr << "Font string length " << sl;
    std::cerr << " rounded " << ((sl + 3) >> 2) << std::endl;
    //Xwindow::X11sock -> assert();
    sockPtr -> assert();
    //Xwindow::X11sock -> put((char *) &reply,sizeof(reply));
    sockPtr -> put((char *) &reply,sizeof(reply));
    //Xwindow::X11sock -> put((char *) wrkptr -> properties,(pl = (8 * reply.nFontProps)));
    sockPtr -> put((char *) wrkptr -> properties,(pl = (8 * reply.nFontProps)));
//    Xwindow::X11sock -> put(*namePtr++,sl);
    //Xwindow::X11sock -> put(*namePtr,sl);
    sockPtr -> put(*namePtr,sl);
    //Xwindow::X11sock -> put("    ",( 4 - (sl % 4 )) % 4);
    sockPtr -> put("    ",( 4 - (sl % 4 )) % 4);
    //Xwindow::X11sock -> flush();
    sockPtr -> flush();
    wrkptr++;
    }
// Last in series
reply.nameLength = 0;
reply.length = 7;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
// Comment out for now
//::XFreeFontInfo(namePtr,fontPtr,num);
}

int checkJavaWid(int wid)
{
int jid;
Xwindow *ptr = rootWin -> AddressWin(wid);

if ((jid = ptr -> JavaWid(wid)) == -1 )
   {
   jid = ptr -> CreateJavaWin();
   }
return(jid);
}

void getFontPath(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetFontPathReply reply;
char **pathPtr,**wrkPtr;
int  i,num,l,nl;

std::cerr << "Get Font Path" << std::endl;
reply.type = 1;
reply.sequenceNumber = sequenceNum;
pathPtr = XGetFontPath(Xwindow::display,&num);
reply.nPaths = num;
nl = 0;
wrkPtr = pathPtr;
for ( i = 0; i < num; i++)
    {
    nl += ( 1 + strlen(*wrkPtr++));
    }
reply.length = (nl + 3)/4;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
//Xwindow::X11sock -> assert();
sockPtr -> assert();
wrkPtr = pathPtr;
for ( i = 0; i < num; i++)
    {
    //Xwindow::X11sock -> putByte(l = strlen(*wrkPtr));
    sockPtr -> putByte(l = strlen(*wrkPtr));
    //Xwindow::X11sock -> put(*wrkPtr++,l);
    sockPtr -> put(*wrkPtr++,l);
    }
i = 0;
//Xwindow::X11sock -> put((char *) &i,(reply.length << 2) - nl);
sockPtr -> put((char *) &i,(reply.length << 2) - nl);
//Xwindow::X11sock -> flush();
sockPtr -> flush();
XFreeFontPath(pathPtr);
}

void changeProperty(tcpSocket *sockPtr,xChangePropertyReq *ptr)
{
char *namePtr;
// Should check if application wants event
// Should also deal with actual change

namePtr = XGetAtomName(Xwindow::display,ptr -> property);
std::cerr << "Change Property : " << namePtr << std::endl;

#ifdef OLD
xEvent event;

std::cerr << "Change Property Event" << std::endl;
std::memset(&event,0,sizeof(event));
event.u.u.type = 28;
event.u.u.sequenceNumber = sequenceNum;
event.u.property.window = ptr -> window;
event.u.property.atom = ptr -> property;
event.u.property.time = clock();
event.u.property.state = 0;             // Change Value
//Xwindow::X11sock -> write((char *) &event,sizeof(event));
sockPtr -> write((char *) &event,sizeof(event));
std::cerr << "Send Change Property Event" << std::endl;
#endif
}

void convertSelection(tcpSocket *sockPtr,xConvertSelectionReq *ptr)
{
xEvent event;

std::cerr << "Selection Notify Event" << std::endl;
std::memset(&event,0,sizeof(event));
event.u.u.type = 31;
event.u.u.sequenceNumber = sequenceNum;
event.u.selectionNotify.time = 0;       // Current Time
event.u.selectionNotify.requestor = ptr -> requestor;
event.u.selectionNotify.selection = ptr -> selection;
event.u.selectionNotify.target = ptr -> target;
event.u.selectionNotify.property = ptr -> property;
//Xwindow::X11sock -> write((char *) &event,sizeof(event));
sockPtr -> write((char *) &event,sizeof(event));
std::cerr << "Send Change Property Event" << std::endl;
}

void mapWindow(tcpSocket *sockPtr,xResourceReq *ptr)
{
int pstate,count;
Xwindow *winptr = rootWin -> AddressWin(ptr -> id);

std::cerr << "Map Window : " << ptr -> id << std::endl;
if ( winptr != NULL )
   {
   std::cerr << "Get ParentMapStat" << std::endl;
   pstate = winptr -> ParentMapState();
   Xwindow::javasock -> putExposeMapHeader();
   std::cerr << "Now Map the Window parent state :" << pstate << std::endl;
   winptr -> MapWindow(sockPtr,pstate,sequenceNum);
   if ( pstate == 2 )
      {
      winptr -> exposePendingSubWindows(sockPtr,sequenceNum);
      }
   Xwindow::javasock -> flushExposeMapHeader();
   } 
}

void unMapWindow(tcpSocket *sockPtr,xResourceReq *ptr)
{
Xwindow *winptr = rootWin -> AddressWin(ptr -> id);
// UnMapWindow and return JavaId
ptr -> id  = winptr -> UnMapWindow();
Xwindow::javasock -> write((char *) ptr,sizeof(xResourceReq));
std::cerr << "Send UnMapWindow Request" << std::endl;
}

void mapSubwindows(tcpSocket *sockPtr,xResourceReq *ptr)
{
int count;
Xwindow *winptr = rootWin -> AddressWin(ptr -> id);

std::cerr << "Map SubWindows" << std::endl;
if ( winptr != NULL )
   {
   Xwindow::javasock -> putExposeMapHeader();
   winptr -> MapSubWindows(sockPtr,sequenceNum);
   Xwindow::javasock -> flushExposeMapHeader();
   }
}
void sendDrawableColMap(int d,int cm)
{
struct
    {
    CARD8 reqType;
    BYTE pad;
    CARD16 length B16;
    Drawable drawable B32;
    Colormap map B32;
    } xSendDrawableColMapReq;

std::cerr << "Send Drawable Colour Map" << std::endl;    
xSendDrawableColMapReq.reqType = 200;
xSendDrawableColMapReq.length = 3;
xSendDrawableColMapReq.drawable = d;
xSendDrawableColMapReq.map = cm;
Xwindow::javasock -> write((char *) &xSendDrawableColMapReq,sizeof(xSendDrawableColMapReq));
}


void putImage(xPutImageReq *ptr)
{
int i;
int *wrkPtr;
Xwindow   *winPtr; 
int       colmap,jw;
ColourMap *mapPtr;

std::cerr << "PutImage Request" << std::endl;
winPtr = rootWin -> AddressWin(ptr -> drawable);
jw = winPtr -> getJavaWid();
// If less than 24 bit colour we may need to send ColourMap
if ( ptr -> depth < 24 )
   {
   std::cerr << "Drawable : " << ptr -> drawable << std::endl;   
   colmap = winPtr -> getColourMap();
   std::cerr << "Colour Map : ";
   printHex(colmap);
   mapPtr = rootColourMap -> Address(colmap);
   if (mapPtr -> getDownLoaded() == 0 )
      {
      mapPtr -> sendColourMap();
      }
   sendDrawableColMap(jw,colmap);
   }
std::cerr << "Send PutImage Request" << std::endl;
ptr -> drawable = jw;
// Printout for debugging
//wrkPtr = (int *) ptr + (sizeof(xPutImageReq) >> 2);
//for (i = 0; i < 16; i++ )
//    {
//    printHex(*wrkPtr);
//    std::cerr << " " << std::endl;
//    wrkPtr++;
//    } 
Xwindow::javasock -> write((char *) ptr,(ptr -> length) << 2);
}

void queryExtension(tcpSocket *sockPtr,xQueryExtensionReq *ptr)
{
xQueryExtensionReply reply;
char extension[120];

// Get extension
std::memset(extension,0,sizeof(extension));
::strncpy(extension,(char *) ptr + sizeof(xQueryExtensionReq),ptr -> nbytes);

std::cerr << "Query Extension : " << extension << std::endl;

// Reply Not supported
std::cerr << "****** Reply : Not supported" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
// None  present = 0;
reply.present = 0;
reply.sequenceNumber = sequenceNum;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
}

void getSelectionOwner(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetSelectionOwnerReply reply;

std::cerr << "Get Selection Owner - Atom : " << ptr->id << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
// Set saved selection owner
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
}

void setSelectionOwner(xResourceReq *ptr)
{
std::cerr << "Set Selection Owner - Window : " << ptr->id << std::endl;
// set saved selection owner
}

void queryColors(tcpSocket *sockPtr,xQueryColorsReq *ptr)
{
xQueryColorsReply reply;
xrgb rgb;

std::cerr << "Query Colors" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
reply.length = 4;
// For now just do as Xcalc trace
reply.nColors = 2;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
rgb.red   = 0;
rgb.blue  = 0;
rgb.green = 0;
//Xwindow::X11sock -> write((char *) &rgb,sizeof(rgb));
sockPtr -> write((char *) &rgb,sizeof(rgb));
rgb.red   = 0xFF00;
rgb.blue  = 0xFF00;
rgb.green = 0xFF00;
//Xwindow::X11sock -> write((char *) &rgb,sizeof(rgb));
sockPtr -> write((char *) &rgb,sizeof(rgb));
}

void allocColor(tcpSocket *sockPtr,xAllocColorReq *ptr)
{
//  Status status;
//    XColor xcolour;
    int xcolour;
    xAllocColorReply reply;
    ColourMap *mapPtr;
    int pixel;
    	
    std::cerr << "AllocColor - ColorMap :" << ptr -> cmap
          << " Red   : " << ((ptr -> red) >> 8 )
          << " Green : " << ((ptr -> green) >> 8)
          << " Blue  : " << ((ptr -> blue) >> 8)
          << std::endl;
    // Java PutImage requires colour to be RGBA where A is alpha
    xcolour = ((ptr -> red >> 8) << 24) | (( ptr -> green >> 8) << 16) | ((ptr->blue >> 8) << 8) | 0xFF;
    std::cerr << "Colour : ";
    printHex(xcolour);
    // uncomment if deal with AllocColor ourselves
    //
    //mapPtr = rootColourMap -> Address(ptr-> cmap);
    //ptr -> pixel = mapPtr -> AllocColour(xcolour);  
    // Check for -1 map full#

    // Does not work if local XServer only supports 24bit
    //std::memset(&xcolour,0,sizeof(xcolour));
    //xcolour.red   = ptr -> red & 0xFF;
    //xcolour.green = ptr -> green & 0xFF;
    //xcolour.blue  = ptr -> blue & 0xFF;
    //status = XAllocColor(Xwindow::display,ptr -> cmap,&xcolour);          
    //if (status == 0 )
    //   std::cerr << "XAllocColor failed" << std::endl;
      
    // Just send back as per allocate request if only negotiated 24bit colours
    pixel = xcolour;
    // Send the Reply
    std::memset(&reply,0,sizeof(reply));
    reply.type = 1;
    reply.sequenceNumber = sequenceNum;
    reply.length = 0;
    reply.red    = ptr -> red;
    reply.green  = ptr -> green;
    reply.blue   = ptr -> blue;
    reply.pixel  = pixel;
    std::cerr << "Pixel : "; 
    printHex(pixel);
    //Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
    sockPtr -> write((char *) &reply,sizeof(reply));
    
    // Add code to send to java if not a direct colour and downloaded     
}
void allocNamedColor(tcpSocket *sockPtr,xAllocNamedColorReq *ptr)
{
    Status status;
    XColor screenColour;
    XColor exactColour; 
    char name[MAXFONTNAME];
    xAllocNamedColorReply reply;    
    ::strncpy(name,(char *) ptr + sizeof(xAllocNamedColorReq),ptr -> nbytes);
    name[ptr -> nbytes] = NULL;
    std::cerr << "AllocNamedColor : " << name << " ColorMap :" << ptr -> cmap << std::endl;
    // Do the actual AllocName at the Server
    std::memset(&screenColour,0,sizeof(screenColour));
    std::memset(&exactColour,0,sizeof(exactColour));
    status = XAllocNamedColor(Xwindow::display,ptr -> cmap,name,&screenColour,&exactColour);          
    if (status == 0 )
       std::cerr << "XAllocNamedColor failed" << std::endl;
       
    // Send the Reply
    std::memset(&reply,0,sizeof(reply));
    reply.type = 1;
    reply.sequenceNumber = sequenceNum;
    reply.length 	 = 0;
    reply.pixel       = exactColour.pixel;
    reply.exactRed    = exactColour.red;
    reply.exactGreen  = exactColour.green;
    reply.exactBlue   = exactColour.blue;
    reply.screenRed   = screenColour.red;
    reply.screenGreen = screenColour.green;
    reply.screenBlue  = screenColour.blue;
    //Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
    sockPtr -> write((char *) &reply,sizeof(reply));
    // Add code to send to java if not a direct colour     
}


void lookupColor(tcpSocket *sockPtr,xLookupColorReq *ptr)
{
    Status status;
    xLookupColorReply reply;
    XColor returnColour,screenColour;
    char name[MAXFONTNAME];
    ::strncpy(name,(char *) ptr + sizeof(xLookupColorReq),ptr -> nbytes);
    name[ptr -> nbytes] = NULL;
    std::cerr << "LookupColor : " << name << " ColorMap :" << ptr -> cmap << std::endl;

    status = XLookupColor(Xwindow::display,ptr -> cmap,name,&returnColour,&screenColour);          
    if (status == 0 )
       std::cerr << "XLookupColor failed" << std::endl;

    // Send the Reply
    std::memset(&reply,0,sizeof(reply));
    reply.type = 1;
    reply.sequenceNumber = sequenceNum;
    reply.length 	 = 0;
    reply.exactRed    = returnColour.red;
    reply.exactGreen  = returnColour.green;
    reply.exactBlue   = returnColour.blue;
    reply.screenRed   = screenColour.red;
    reply.screenGreen = screenColour.green;
    reply.screenBlue  = screenColour.blue;
    //Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
    sockPtr -> write((char *) &reply,sizeof(reply));
    // Add code to send to java if not a direct colour  
}

int getValueMask(int mask,int *ptr,int bitoffset)
{
// set X.h for bitoffset values
int i;

for ( i = 1 ; i < bitoffset ; i++)
   {
   if ((mask & 1) == 1)
      {
      ptr++;
      }
   mask = mask >> 1;
   } 
return(*ptr);
}

int* getPointerMask(int mask,int *ptr,int bitoffset)
{
// set X.h for bitoffset values
int i;

for ( i = 1 ; i < bitoffset ; i++)
   {
   if ((mask & 1) == 1)
      {
      ptr++;
      }
   mask = mask >> 1;
   } 
return(ptr);
}

int convertColourTo24bit(int c)
{
// Not sure if this is needed as I think c is already 24bit
    Screen *screen;
    Status status;
    XColor col;

    col.pixel = c;
    std::cerr << "Convert colour to 24 bit Colour : ";
    printHex(c);
    // Make sure valid integer
    col.pixel = col.pixel & 0x00FFFFFF;
//    status = ::XQueryColor(Xwindow::display,colourMap,&col);
    // Use 24bit colour map to do convesrion
    screen = XDefaultScreenOfDisplay(Xwindow::display);
    status = ::XQueryColor(Xwindow::display,XDefaultColormapOfScreen(screen),&col);      
    if (status == 0 )
       std::cerr << "XQueryColor failed" << std::endl;
    std::cerr << "RGB colour :  Red " << col.red << " Green " << col.green << " Blue " << col.blue << std::endl;
    //printHex(col.red);
    //printHex(col.green);
    //printHex(col.blue);
    //std::cerr << "Upper Bytes" << std::endl;
    //printHex(col.red >> 8);
    //printHex(col.green >> 8);
    //printHex(col.blue >> 8);
    //std::cerr << "Shifted Bytes" << std::endl;
    //printHex((col.red >> 8) << 16);
    //printHex((col.green >> 8) << 8);
    //printHex(col.blue >> 8);
    //std::cerr << "Return Value ";
    //printHex(((col.red >> 8) << 16 ) | ((col.green >> 8) << 8) | (col.blue >> 8) );
    return(((col.red >> 8) << 16 ) | ((col.green >> 8) << 8) | (col.blue >> 8) );
}

void processWindowMask(Xwindow *winPtr,int mask,int *ptr)
{
int value, col, *wrk;
int colMap; 
std::cerr << "Window Mask : ";
printHex(mask);
if (( mask & CWBackPixel ) == CWBackPixel )
   {
   value = getValueMask(mask,ptr,1);
   std::cerr << "BackGround Pixel : ";
   winPtr -> setBackGroundColour(convertColourTo24bit(value));
   printHex(value);
   }
if (( mask & CWBorderPixel ) == CWBorderPixel )
   {
   value = getValueMask(mask,ptr,3);
   std::cerr << "Border Pixel : ";
   printHex(value);
   winPtr -> setBorderColour(convertColourTo24bit(value));
   }
if (( mask & CWEventMask ) == CWEventMask )
   {
   value = getValueMask(mask,ptr,11);
   std::cerr << "Event Mask : ";
   printHex(value);
   winPtr -> setEventMask(value);
   }
if (( mask & CWColormap ) == CWColormap )
   {
   value = getValueMask(mask,ptr,13);
   std::cerr << "Colour Mask : ";
   printHex(value);
   winPtr -> setColourMap(value);
   }
}

void processGCmask(int mask,int *ptr)
{
    int *wrk;
    int col;

    if ((mask & GCForeground ) == GCForeground )
       {
       col = getValueMask(mask,ptr,2);
       std::cerr << "ForeGround : ";
       printHex(col);
       col = convertColourTo24bit(col);
       //std::cerr << "Converted Colour : ";
       //printHex(col);
       wrk = getPointerMask(mask,ptr,2);
       *wrk = col;
       //col = getValueMask(mask,wrk1,2);
       //std::cerr << "Changed ForeGround : ";
       //printHex(col);
       }
    if ((mask & GCBackground ) == GCBackground )
       {
       col = getValueMask(mask,ptr,3);
       std::cerr << "BackGround : ";
       printHex(col);
       col = convertColourTo24bit(col);
       wrk = getPointerMask(mask,ptr,3);
       *wrk = col;
       }
}

void createGC(xCreateGCReq *ptr)
    {
    Xwindow *winPtr; 
    int gc,mask;
    int colMap;
    
    std::cerr << "Create GC" << std::endl;
    gc = ptr -> gc;
    std::cerr << "GC : " << gc << std::endl;
    std::cerr << "Window : " << ptr -> drawable << std::endl;
    winPtr = rootWin -> AddressWin(ptr -> drawable);
    colMap = winPtr -> getColourMap();
    std::cerr << "Colour Map : ";
    printHex(colMap);
    new GraphicContext(gc,colMap);
    mask = ptr -> mask;
    std::cerr << "Mask : ";
    printHex(mask);
    processGCmask(mask,(int *)ptr + (sizeof(xCreateGCReq) >> 2));
    Xwindow::javasock -> write((char *) ptr,(ptr -> length) << 2);
    }

void changeGC(xChangeGCReq *ptr)
{
    GraphicContext *gcPtr; 
    int mask,colMap;
  
    std::cerr << "Change GC" << std::endl;
    std::cerr << "GC : " << ptr -> gc << std::endl;
    // Change has no drawable !!!!!
    gcPtr = rootGC -> Address(ptr -> gc);
    mask = ptr -> mask;
    std::cerr << "Mask : ";
    printHex(mask);
    processGCmask(mask,(int *)ptr + (sizeof(xChangeGCReq) >> 2));
    Xwindow::javasock -> write((char *) ptr,(ptr -> length) << 2);
    }

	
void createWindow(xCreateWindowReq *ptr)
{
Xwindow *winptr, *parentPtr;
int     mask;
std::cerr << "Create X11 window : " << ptr -> wid << " parent : " << ptr -> parent << std::endl;
std::cerr << "width : " << ptr -> width << " height : " << ptr -> height << " depth : " << ptr -> depth << std::endl;
// ::printf("WID(hex) : %x Parent %x \n",ptr -> wid,ptr -> parent);std::cerr << "Create X11 window : " << ptr -> wid << " parent : " << ptr -> parent << std::endl;

mask = ptr-> mask;
if ((parentPtr = rootWin -> AddressWin(ptr -> parent)) != 0 )
   {
   winptr = parentPtr -> CreateSubWindow(ptr -> wid,ptr -> x,ptr -> y,ptr -> width,ptr -> height,ptr -> depth,ptr -> borderWidth); 
   processWindowMask(winptr,mask,(int *) ptr + ( sizeof(xCreateWindowReq) >> 2 ));
   winptr -> CreateJavaWin();
   }
else
   {
   std::cerr << "Error Parent Window " << ptr -> parent << "does not exist" << std::endl;
   }
}

void configWindow(xConfigureWindowReq *ptr)
{
Xwindow *winPtr = rootWin -> AddressWin(ptr -> window);
int id = winPtr -> JavaWid(ptr -> window);

std::cerr << "Config Window" << std::endl;
winPtr -> ConfigWindow(ptr -> mask,((int *) ptr) + 3);

// If already created in java forward with ID changed
if ( id != -1 )
   {
   ptr -> window = id;
   Xwindow::javasock -> write((char *) ptr,(ptr -> length)  << 2);
   }
}

void createPixmap(xCreatePixmapReq *ptr)
{
Xwindow *pm;

std::cerr << "Create PixMap : " << ptr-> pid <<
             " Width : " << ptr-> width <<
             " Height : " << ptr-> height <<
             " Depth : " << ptr-> depth << std::endl;
// Create Pixmap contol on server
pm = rootWin -> CreatePixmap(ptr-> pid,ptr -> width,ptr -> height,ptr -> depth);
// Create Pixmap on Java Client
std::cerr << "Create Java Pixmap : "<< pm << std::endl;
pm -> DumpWindow();
pm -> CreateJavaPixmap();
}

void freePixmap(xResourceReq *ptr)
{
std::cerr << "Free PixMap : " << ptr-> id << std::endl;
}

void changeWindowAttributes(xChangeWindowAttributesReq *ptr)
{
Xwindow *winPtr;
int     mask;

std::cerr << "Change Window Attributes" << std::endl;
winPtr = rootWin -> AddressWin(ptr -> window);
mask = ptr -> valueMask;
processWindowMask(winPtr,mask,(int *) ptr + (sizeof(xChangeWindowAttributesReq) >> 2));
//
//      Send Config Notify Event
//
// Temp comment for Raspberry Pi
//winPtr -> ConfigNotify(sequenceNum);
//
//      Note More events than this were generated for xclock but bugs since
//
//      Not convined that this needs to Send Expose Event
//
//if (( mask & ExposureMask ) == ExposureMask )
//   {
//   std::cerr << "Change attribute to expose" << std::endl;
//   winPtr -> expose(sequenceNum);
//   winPtr -> exposePendingSubWindows(sequenceNum);
//   }
}

void getWindowAttributes(tcpSocket *sockPtr,xResourceReq *ptr)
{
Xwindow *winPtr;

std::cerr << "Get Window Attributes" << std::endl;
winPtr = rootWin -> AddressWin(ptr -> id);
winPtr -> GetWindowAttributes(sockPtr,sequenceNum);
}

void destroyWindow(tcpSocket *sockPtr,xResourceReq *ptr)
{
xEvent event;

std::cerr << "Destroy Notify Event" << std::endl;
std::memset(&event,0,sizeof(event));
event.u.u.type = 28;
event.u.u.sequenceNumber = sequenceNum;
event.u.destroyNotify.event = ptr -> id;
event.u.destroyNotify.window = ptr -> id;
//Xwindow::X11sock -> write((char *) &event,sizeof(event));
sockPtr -> write((char *) &event,sizeof(event));
std::cerr << "Send Destroy Notify Event" << std::endl;

// Convert window Id from X11 to java Id & forward request.
if (( ptr -> id = rootWin -> JavaWid(ptr -> id)) != -1 )
   Xwindow::javasock -> write((char *) ptr,(ptr -> length)  << 2);
}

void getGeometry(tcpSocket *sockPtr,xResourceReq *ptr)
{
Xwindow *winptr = rootWin -> AddressWin(ptr -> id);

std::cerr << "Get Geometry" << std::endl;
if ( winptr != NULL )
   winptr -> GetGeometry(sockPtr,rootWin -> X11windowId(0),sequenceNum);
}

void queryTree(tcpSocket *sockPtr,xResourceReq *ptr)
{
Xwindow *winptr = rootWin -> AddressWin(ptr -> id);

std::cerr << "Query Tree" << std::endl;
if ( winptr != NULL )
   winptr -> QueryTree(sockPtr,rootWin -> X11windowId(0),sequenceNum);
}


void clearArea(tcpSocket *sockPtr,xClearAreaReq *ptr)
{
Xwindow *winPtr = rootWin -> AddressWin(ptr -> window);

std::cerr << "Clear Area Routine : " << (int) (ptr -> exposures) << " :" << std::endl;
if ( ptr -> exposures == (int) 1 )
   {
   std::cerr << "Clear Area Expose" << std::endl;
   winPtr -> exposeMust(sockPtr,sequenceNum,ptr -> x,ptr -> y,
                                    ptr -> width, ptr -> height);
   }
// Convert window Id from X11 to java Id & forward request.
if (( ptr -> window = winPtr -> JavaWid(ptr -> window)) != -1 )
   {
   Xwindow::javasock -> write((char *) ptr,(ptr -> length)  << 2);
   }
else
   {
   std::cerr << "Clear Area for Non exposed Area" << std::endl;
   }
}

void getKeyboardMapping(tcpSocket *sockPtr,xGetKeyboardMappingReq *ptr)
{
// May not have to do all this, just match java to mapping
// Starts at 9, for 100, 3 per key
// keymap in include keymap.c

xGetKeyboardMappingReply reply;

std::cerr << "Get Keyboard Mapping" << std::endl;
std::memset(&reply,0,sizeof(reply));
if ( ptr -> count <= 133 )
   {
   reply.type = 1;
   reply.keySymsPerKeyCode = 3;
   reply.sequenceNumber = sequenceNum;
   reply.length = 3 * (ptr -> count);
   //Xwindow::X11sock -> write((char *) &reply,32);
   sockPtr -> write((char *) &reply,32);
   //Xwindow::X11sock -> write((char *) &keymap[(ptr -> firstKeyCode) - FIRSTKEY],
   sockPtr -> write((char *) &keymap[(ptr -> firstKeyCode) - FIRSTKEY],
                    12 * (ptr -> count));
   }
else
   {
   std::cerr << "Count : " << ptr -> count << " larger than keymap table " <<std::endl;
   }
}

void getKeyboardControl(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetKeyboardControlReply reply;

std::cerr << "Get Keyboard Control" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.globalAutoRepeat = 0;
reply.sequenceNumber = sequenceNum;
reply.length = 5;
reply.ledMask = 0;
reply.keyClickPercent = 0;
reply.bellPercent = 0x32;
reply.bellPitch = 0x190;
reply.bellDuration = 0x64;
//Xwindow::X11sock -> write((char *) &reply,sizeof(reply));
sockPtr -> write((char *) &reply,sizeof(reply));
}

void getModifierMapping(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetModifierMappingReply reply;

char mods[16] = { 0x34, 0x41, 0x26, 0x00, 0x42, 0x48, 0x44, 0x00,
                  0x46, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00 };

std::cerr << "Get Modifier Mapping" << std::endl;
std::memset((char *) &reply,0,sizeof(reply));
reply.type = 1;
reply.numKeyPerModifier = 2;
reply.sequenceNumber = sequenceNum;
reply.length = 4;
//Xwindow::X11sock -> write((char *) &reply,32);
sockPtr -> write((char *) &reply,32);
//Xwindow::X11sock -> write((char *) &mods,16);
sockPtr -> write((char *) &mods,16);
}

void grabKeyboard(tcpSocket *sockPtr,xGrabKeyboardReq *ptr)
{
xGrabKeyboardReply reply;

std::cerr << "Grab Keyboard" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.status = 0;
reply.sequenceNumber = sequenceNum;
reply.length = 0;
//Xwindow::X11sock -> write((char *) &reply,32);
sockPtr -> write((char *) &reply,32);
}

void getInputFocus(tcpSocket *sockPtr)
{
xGetInputFocusReply reply;

std::cerr << "Get Input Focus" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
reply.length = 0;
//Xwindow::X11sock -> write((char *) &reply,32);
sockPtr -> write((char *) &reply,32);
}

void getScreenSaver(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetScreenSaverReply reply;

std::cerr << "Get Screen Saver" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
reply.length = 0;
//Xwindow::X11sock -> write((char *) &reply,32);
sockPtr -> write((char *) &reply,32);
}

void getPointerControl(tcpSocket *sockPtr,xResourceReq *ptr)
{
xGetPointerControlReply reply;

std::cerr << "Get Pointer Control" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
reply.length = 0;
reply.accelNumerator = 0x02;
reply.accelDenominator = 0x01;
reply.threshold = 0x04;
//Xwindow::X11sock -> write((char *) &reply,32);
sockPtr -> write((char *) &reply,32);
}

void queryBestSize(tcpSocket *sockPtr,xQueryBestSizeReq *ptr)
{
xQueryBestSizeReply reply;

std::cerr << "Query Best Size" << std::endl;
std::memset(&reply,0,sizeof(reply));
reply.type = 1;
reply.sequenceNumber = sequenceNum;
reply.length = 0;
reply.width = ptr -> width;
reply.height = ptr -> height;
//Xwindow::X11sock -> write((char *) &reply,32);
sockPtr -> write((char *) &reply,32);
}

void reportRequest(int type)
{
	switch (type)
	{
	case X_ConvertSelection :
           std::cerr << "X_ConvertSelection" << std::endl;
           break;

      case X_InternAtom :
      	   std::cerr << "X_InternAtom" << std::endl;
           break;

      case X_GetAtomName :
           std::cerr << "X_GetAtomName" << std::endl;
           break;

      case X_QueryFont :
           std::cerr << "X_QueryFont" << std::endl;
           break;

      case X_OpenFont :
      	   std::cerr << "X_OpenFont" << std::endl;
           break;

      case X_ListFonts :
           std::cerr << "X_ListFonts" << std::endl;
           break;

      case X_GetFontPath :
           std::cerr << "X_GetFontPath" << std::endl;
           break;

      case X_ListFontsWithInfo :
           std::cerr << "X_ListFontsWithInfo" << std::endl;
           break;

      case X_ChangeProperty :
           std::cerr << "X_ChangeProperty" << std::endl;
           break;

      case X_MapWindow :
           std::cerr << "X_MapWindow" << std::endl;
           break;

      case X_MapSubwindows :
           std::cerr << "X_MapSubwindows" << std::endl;
           break;

      case X_UnmapWindow :
           std::cerr << "X_UnmapWindow" << std::endl;
           break;

      case X_ChangeWindowAttributes :
           std::cerr << "X_ChangeWindowAttributes" << std::endl;
           break;

      case X_GetWindowAttributes :
           std::cerr << "X_GetwindowAttributes" << std::endl;
           break;

      case X_GetGeometry :
      	   std::cerr << "X_GetGeometry" << std::endl;
           break;

      case X_QueryTree :
           std::cerr << "X_QueryTree" << std::endl;
           break;

      case X_GetProperty :
           std::cerr << "X_GetProperty" << std::endl;
           break;

      case X_QueryExtension :
           std::cerr << "X_QueryExtension" << std::endl;
           break;

      case X_QueryColors :
	   std::cerr << "X_QueryColors" << std::endl;
	   break;

      case X_CreatePixmap :
           std::cerr << "X_CreatePixMap" << std::endl;
           break;
           
      case X_FreePixmap :
      	   std::cerr << "X_FreePixmap" << std::endl;
      	   break;

      case X_SetSelectionOwner :
           std::cerr << "X_SetSelectionOwner" << std::endl;
           break;

      case X_GetSelectionOwner :
           std::cerr << "X_GetSelectionOwner" << std::endl;
           break;

      case X_GrabKeyboard :
           std::cerr << "X_GrabKeyboard" << std::endl;
           break;

      case X_GetKeyboardControl :
           std::cerr << "X_GetKyboardControl" << std::endl;
           break;

      case X_GetKeyboardMapping :
           std::cerr << "X_GetKeyboardMapping" << std::endl;
           break;

      case X_GetModifierMapping :
           std::cerr << "X_GetModiiferMapping" << std::endl;
           break;

      case X_GetPointerControl :
           std::cerr << "X_GetPointerControl" << std::endl;
           break;

      case X_GetScreenSaver :
           std::cerr << "X_GetScreenSaver" << std::endl;
           break;

      case X_QueryBestSize :
           std::cerr << "X_QueryBestSize" << std::endl;
           break;

      case X_CreateWindow :
           std::cerr << "X_CreateWindow" << std::endl;
           break;

      case X_ConfigureWindow :
           std::cerr << "X_ConfigureWindow" << std::endl;
           break;

      case X_DestroyWindow :
           std::cerr << "X_DestroyWindow" << std::endl;
           break;

      case X_ClearArea :
           std::cerr << "Clear Area" << std::endl;
           break;

      case X_AllocNamedColor :
      	   std::cerr << "X_AllocNamedColor" << std::endl;
      	   break;
      	   
      case X_AllocColor :
      	   std::cerr << "X_AllocColor" << std::endl;
      	   break;
      	   
      case X_GetInputFocus :
      	   std::cerr << "X_GetInputFocus" << std::endl;
      	   break;
      	   
      case X_PolyPoint :
           std::cerr << "X_PolyPoint" << std::endl;
           break;
           
      case X_PolyLine :
           std::cerr << "X_PolyLine" << std::endl;
           break;
           
      case X_PolySegment :
           std::cerr << "X_PolySegment" << std::endl;
           break;
           
      case X_PolyRectangle :
           std::cerr << "X_PolyRectangle" << std::endl;
           break;
           
      case X_PolyArc :
           std::cerr << "X_PolyArc" << std::endl;
           break;
           
      case X_FillPoly :
           std::cerr << "X_FillPoly" << std::endl;
           break;
           
      case X_PolyFillRectangle :
           std::cerr << "X_PolyFillRectangle" << std::endl;
           break;
           
      case X_PolyFillArc :
           std::cerr << "X_PlyFillArc" << std::endl;
           break;
           
      case X_PolyText8 :
           std::cerr << "X_PolyText8" << std::endl;
           break;
           
      case X_PutImage :
           std::cerr << "X_PutImage" << std::endl;
           break;
           
      case X_SetClipRectangles :
           std::cerr << "X_SetClipRectangles" << std::endl;
           break;

      case X_CopyPlane :
      	   std::cerr << "X_CopyPlane" << std::endl;
      	   break;
      	   
      case X_CopyArea :
           std::cerr << "X_CopyArea" << std::endl;
           break;
 
      case X_CreateGC :
           std::cerr << "X_Create GC" << std::endl;
	   break;
			      
      case X_FreeGC :
      	   std::cerr << "X_FreeGC" << std::endl;
      	   break;
      	   
      case X_CreateGlyphCursor :
           std::cerr << "X_CreateGlyphCursor" << std::endl;
           break;
           
      case X_ChangeGC :
           std::cerr << "X_ChangeGC" << std::endl;
           break;

      case X_LookupColor :
	   std::cerr << "X_LookupColor" << std::endl;
	   break;

      case X_ReparentWindow :
	   std::cerr << "X_ReparentWindow" << std::endl;
	   break;

      case X_GrabServer :
           std::cerr << "X_GrabServer" << std::endl;
	   break;
           
      case X_UngrabServer :
           std::cerr << "X_UngrabServer" << std::endl;
	   break;
           
      case 129 :     // Shape extension
           std::cerr << "X_ShapeExtension" << std::endl;
           break;

      default :
           std::cerr << "Not yet reported : " << type << std::endl;
		   break;	
	}
	
}

int processRequests(tcpSocket *sockPtr)
{
int len,hl,ret;
struct
  {
  xResourceReq req;
  int data[MAXREQUESTSIZE];		// Maximum Request size set in connection setup
  } requestBuff;

std::cerr << "Process X11 Request : " << sockPtr -> sockfd << std::endl;
len = 4;
while ( len > 0 )       // Need to change to while bytes available
   {
   // Read in Header
   if (( hl = sockPtr -> readBlock((char *) &requestBuff.req,4)) != 4)
      {
      if ( hl == 0 )
         {
         std::cerr << "End of X11 Stream - Header" << std::endl;
         return(0);
         }
      else
         {
         std::cerr << "Error reading Header : " << hl << " Bytes Read " << std::endl;
         return(-2);
         }
      }
   // Get remaining length in bytes
   len = ( requestBuff.req.length - 1) << 2;
   std::cerr << "Request length : " << requestBuff.req.length << " bytes : " << (requestBuff.req.length << 2) << std::endl;
   if ( requestBuff.req.length > MAXREQUESTSIZE )
      {
      std::cerr << "X11 Request data > MaxRequestSize : " << requestBuff.req.length << std::endl;
      return(-2);
      }
   if (( ret = sockPtr -> readBlock((char *) &requestBuff.req.id,len)) != len )
      {
      if ( ret == 0 )
	 {
         std::cerr << "End of X11 Stream - Data" << std::endl;
         return(-3);
	 }
      else
	 {
         std::cerr << "Error reading Request data" << std::endl;
         return(-2);
	 }
      }
   len += 4;
   sequenceNum++;
   std::cerr << "Request Type : " << (int) requestBuff.req.reqType << " Sequence Number : " << sequenceNum << std::endl;
   reportRequest( requestBuff.req.reqType );
   switch ( requestBuff.req.reqType )
      {
      //************************************************//
      //  Deal with locally                             //
      //************************************************//
      case X_ConvertSelection :
           convertSelection(sockPtr,(xConvertSelectionReq *) &requestBuff);
           break;

      case X_InternAtom :
           internAtom(sockPtr,(xInternAtomReq *) &requestBuff);
           break;

      case X_GetAtomName :
           getAtomName(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_QueryFont :
           queryFont(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_OpenFont :
           openFont((xOpenFontReq *) &requestBuff);
           break;

      case X_ListFonts :
           listFonts(sockPtr,(xListFontsReq *) &requestBuff);
           break;

      case X_GetFontPath :
           getFontPath(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_ListFontsWithInfo :
           listFontsWithInfo(sockPtr,(xListFontsReq *) &requestBuff);
           break;

      case X_ChangeProperty :
           changeProperty(sockPtr,(xChangePropertyReq *) &requestBuff);
           break;

      case X_ChangeWindowAttributes :
           changeWindowAttributes((xChangeWindowAttributesReq *) &requestBuff);
           break;

      case X_GetWindowAttributes :
           getWindowAttributes(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_GetGeometry :
           getGeometry(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_QueryTree :
           queryTree(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_GetProperty :
           getProperty(sockPtr,(xGetPropertyReq *) &requestBuff);
           break;

      case X_QueryExtension :
           queryExtension(sockPtr,(xQueryExtensionReq *) &requestBuff);
           break;

      case X_GetInputFocus :
	   getInputFocus(sockPtr);
	   break;

      case X_AllocColor :			// Deal with colour locally pass to gc 24bit colour
	   allocColor(sockPtr,(xAllocColorReq *) &requestBuff);
	   break;
	  	   
      case X_AllocNamedColor :			// Deal with colour locally pass to gc 24bit colour
	   allocNamedColor(sockPtr,(xAllocNamedColorReq *) &requestBuff);
	   break;
	 	  
//      case X_QueryColors :
//           queryColors((xQueryColorsReq *) &requestBuff);
//           break;

      case X_LookupColor :			// Deal with colour locally pass to gc 24bit colour
          lookupColor(sockPtr,(xLookupColorReq *) &requestBuff);
	  break;	

      case X_GetSelectionOwner :
           getSelectionOwner(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_SetSelectionOwner :
           setSelectionOwner((xResourceReq *) &requestBuff);
           break;

      case X_GrabKeyboard :
           grabKeyboard(sockPtr,(xGrabKeyboardReq *) &requestBuff);
           break;

      case X_GetKeyboardControl :
           getKeyboardControl(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_GetKeyboardMapping :
           getKeyboardMapping(sockPtr,(xGetKeyboardMappingReq *) &requestBuff);
           break;

      case X_GetModifierMapping :
           getModifierMapping(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_GetPointerControl :
           getPointerControl(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_GetScreenSaver :
           getScreenSaver(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_QueryBestSize :
           queryBestSize(sockPtr,(xQueryBestSizeReq *) &requestBuff);
           break;

      //************************************************//
      //  Deal with and need to forward                 //
      //************************************************//
      case X_CreateWindow :
           createWindow((xCreateWindowReq *) &requestBuff);
           break;

      case X_ConfigureWindow :
           configWindow((xConfigureWindowReq *) &requestBuff);
           break;

      case X_DestroyWindow :
           destroyWindow(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_ClearArea :
           std::cerr << "Clear Area" << std::endl;
           clearArea(sockPtr,(xClearAreaReq *) &requestBuff);
           break;
           
      case X_CreatePixmap :
           createPixmap(( xCreatePixmapReq *) &requestBuff);
           break;

      case X_CreateGC :
	   createGC((xCreateGCReq *) &requestBuff);
	   break;

      case X_ChangeGC :
	   changeGC((xChangeGCReq * ) &requestBuff);
	   break;

      case X_FreePixmap :
	   freePixmap(&requestBuff.req);
	   break;

      case X_MapWindow :
           mapWindow(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_MapSubwindows :
           mapSubwindows(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_UnmapWindow :
           unMapWindow(sockPtr,(xResourceReq *) &requestBuff);
           break;

      case X_PutImage :
	   putImage((xPutImageReq *) &requestBuff);
	   break;
      //************************************************//
      //  forward - Reply expected                      //
      //************************************************//
      case X_QueryColors :
#ifdef DEBUG
           std::cerr << "Forward - Reply expected " << std::endl;
           std::cerr << "Send to java : " << len << std::endl;
#endif
           Xwindow::javasock -> write((char *) &requestBuff,len);
           break;

      //************************************************//
      //  forward with Window changed to javaWindow Id  //
      //************************************************//
      case X_PolyPoint :
      case X_PolyLine :
      case X_PolySegment :
      case X_PolyRectangle :
      case X_PolyArc :
      case X_FillPoly :
      case X_PolyFillRectangle :
      case X_PolyFillArc :
      case X_PolyText8 :
           std::cerr << "Forward with WinID " << requestBuff.req.id << std::endl;
           // requestBuff.req.id = checkJavaWid(requestBuff.req.id);
           requestBuff.req.id = rootWin -> JavaWid(requestBuff.req.id);
           if ( requestBuff.req.id > 0 ) 
              {
              std::cerr << " --> Java Id " << requestBuff.req.id << std::endl;
              std::cerr << "Send to java : " << len << std::endl;
              Xwindow::javasock -> write((char *) &requestBuff,len);
	      }
           else
              std::cerr << "Window Not Found" << std::endl;
           break;
      //************************************************//
      //  forward with changed source and dest window   //
      //************************************************//
      case X_CopyPlane :
      case X_CopyArea :
      case X_ReparentWindow :
           requestBuff.req.id = rootWin -> JavaWid(requestBuff.req.id);
           requestBuff.data[0] = rootWin -> JavaWid(requestBuff.data[0]);
           if ( requestBuff.req.id > 0 && requestBuff.data[0] > 0 ) 
              {
              std::cerr << "--> Java Id " << requestBuff.req.id << std::endl;
              // requestBuff.data[0] = checkJavaWid(requestBuff.data[0]);
              std::cerr << "Send to java : " << len << std::endl;
              Xwindow::javasock -> write((char *) &requestBuff,len);
	      }
           else
              std::cerr << "Window Not Found" << std::endl;
           break;
      //************************************************//
      //  Ignore for Now                                //
      //************************************************//

      case X_SetClipRectangles : // Is passed GC not sure how to handle. Is not passed window
	   			      
      case X_GrabServer : 
      case X_UngrabServer : 
      case X_FreeGC :
      case X_CreateGlyphCursor :
      case    129 :     // Shape extension
           break;

      //************************************************//
      //  forward no reply                              //
      //************************************************//
      
			
      default :
#ifdef DEBUG
           std::cerr << "Forward No Reply" << std::endl;
           std::cerr << "Send to java : " << len << std::endl;
#endif
           Xwindow::javasock -> write((char *) &requestBuff,len);
           break;
      }
   return(1);           // DO one request per select for now
   }
return(1);
}

void closeDownClient(void)
{
    std::cerr << "Close Down X Client" << std::endl;
    // Java Client has gone away
    // Close session with Xserver
    XCloseDisplay(Xwindow::display);
    // Close java socket
    std::cerr << "Close Java Socket" << std::endl;
    Xwindow::javasock -> close();
    // Close X11 socket
    std::cerr << "Add Close X Socket" << std::endl;
    //Xwindow::X11sock -> close();
    // End task
    std::cerr << "Kill Client" << std::endl;
    kill(setupPid2,SIGKILL);
    std::cerr << "exit" << std::endl;
    exit(0);
}
//////////////////////////////////
// Process Replies	        //
//------------------------------//
// Returns 	                //
//     n  - Number processed	//
//     0  - End of File	        //
//    -ve - Error		//
//////////////////////////////////
int processReplies(tcpSocket *sockPtr)
{
int ret,len;
short x,y;
Xwindow *winPtr;

struct
  {
  union
    {
    xGenericReply reply;
    xEvent        event;
    } u;
  char data[8196];
  } buff;

std::cerr << "Process Replies" << std::endl;

std::memset(&buff,0,32);
if (( len =  Xwindow::javasock -> readBlock((char *) &buff,32)) != 32 )
   {
   if ( len == 0 )
      {
      std::cerr << "End of Java Stream" << std::endl;
      closeDownClient();
      }
   else
      {
      std::cerr << "Error Reading basic Reply from java" << std::endl;
      return(-2);
      }
   }
len = buff.u.reply.length << 2;
std::cerr << "Reply length : "<< buff.u.reply.length << " len : " << len << std::endl;
if ( len > 0 )
   {
   if (( ret = Xwindow::javasock -> readBlock(buff.data,len)) != len )
      {
      if ( ret == 0 )
	     {
	     std::cerr << "End of Java Stream" << std::endl;
	     closeDownClient();
         }
      else
         {
         std::cerr << "Error Reading additional data from java" << std::endl;
         std::cerr << "Reply Length : "<< len << " Data Read  : "<< ret << std::endl;
         return(-2);
         }
      }
   }
len += 32;

// Update sequence Number as not all passed to java
buff.u.reply.sequenceNumber = sequenceNum;
switch ( buff.u.reply.type )
   {
   case 1 : // Reply
   		std::cerr << "Reply from Java Client" << std::endl;
        break;

   case 2 : // KeyPress
   case 3 : // KeyRelease
   case 4 : // Button Press
   case 5 : // Button Release
        std::cerr << "Event : " << buff.u.reply.type << " Received" << std::endl;
        winPtr = rootWin -> AddressJavaWin(buff.u.event.u.keyButtonPointer.event);
//        winPtr -> rootCoord(buff.u.event.u.keyButtonPointer.eventX,
//            buff.u.event.u.keyButtonPointer.eventY,
//            &buff.u.event.u.keyButtonPointer.rootX,
//                    &buff.u.event.u.keyButtonPointer.rootY);
        winPtr -> rootCoord(buff.u.event.u.keyButtonPointer.eventX,
            buff.u.event.u.keyButtonPointer.eventY,
              &x,&y);
        std::cerr << "Java root coords " << buff.u.event.u.keyButtonPointer.rootX
             << " : " << buff.u.event.u.keyButtonPointer.rootY << std::endl;

        std::cerr << "JavaServ Calc coords " << x << " : " << y << std::endl;
        buff.u.event.u.keyButtonPointer.root = rootWin -> X11windowId(0);
        buff.u.event.u.keyButtonPointer.event = rootWin -> X11windowId(buff.u.event.u.keyButtonPointer.event);
        len = 32;
        break;

   case 65 : // This is really a Reply (1) with Window needing translation at offset 4
        buff.u.reply.type = 1;
        buff.u.reply.data00 = rootWin -> X11windowId(buff.u.reply.data00);
        break;

   default :
        std::cerr << "Unknown Event from Java : " << buff.u.reply.type << std::endl;
        break;
   }
std::cerr << "Send to X client : " << len << std::endl;
//Xwindow::X11sock -> write((char *) &buff,len);
sockPtr -> write((char *) &buff,len);
return(1);
}

int readCommand(char *command)
{
	int hl,len,ret;
struct
  {
//  int len;	
  xReq req;
  int data[1024];
  } requestBuff;
// MUST DO !!!!! Add function to read in Request as this code is repeated
// in process  
std::cerr << "Read Command" << std::endl;
// Read in Header
if (( hl = Xwindow::javasock -> readBlock((char *) &requestBuff.req,4)) != 4)
   {
   if ( hl == 0 )
      {
      std::cerr << "End of Stream" << std::endl;
      return(0);
      }
   else
       {
       std::cerr << "Error reading Header : " << hl << " Bytes Read " << std::endl;
       return(-2);
       }
   } 
// Get remaining length
// len = ( requestBuff.req.length - 1) << 2;
// X sending in 4 byte chuncks
len = requestBuff.req.length;
std::cerr << "Header Read - type : " << (int) requestBuff.req.reqType << " Length " << len << std::endl;
if ( len > 1024 )
   {
   std::cerr << "X11 Request data > 1024 bytes" << std::endl;
   return(-2);
   }
 std::cerr << "Read : " << len << " bytes" << std::endl;  
if (( ret = Xwindow::javasock -> readBlock((char *) &requestBuff.data,len)) != len )
   {
   if ( ret == 0 )
      {
      std::cerr << "End of Stream" << std::endl;
      return(0);
	  }
    else
	   {
       std::cerr << "Error reading Request data" << std::endl;
       return(-2);
	   }
    }
std::cerr << "Copy String : " << std::endl;
dumpHex((char*) requestBuff.data,len);
::strncpy(command,(char *) requestBuff.data,len);
std::cerr << "Command Read : " << command << std::endl;
}



int process(void)
{
SockSet *sockset = new SockSet();
int     ret,v;
int     i,s;

sequenceNum  = 0;
fontEntries  = 0;

s = 0;

sockset -> init();
sockset -> addReadMask(X11Serv);
sockset -> addReadMask(Xwindow::javasock);
do
   {
   std::cerr << "X11 Serv socket : " << X11Serv -> sockfd << std::endl;
   std::cerr << "Select on inputs" << std::endl;
   v = sockset -> select(TIMEOUT);
   //v = sockset -> wait();
   if ( sockset -> isset(Xwindow::javasock))
      {
      if (( ret =  processReplies(X11sock[i])) <= 0 )
         return(ret);
      }
   if ( s > 0 )
      {
      for( i = 0; i < s; i++)
         {
         if ( sockset -> isset(X11sock[i]))
            {
	    ret = processRequests(X11sock[i]);
	    if ( ret == 0 )   // Other end has closed connection
	       {
		std::cerr << "Connection closed : " << s << " : " << i << " : " << X11sock[i] -> sockfd << std::endl;
	       sockset -> removeReadMask(X11sock[i]);
	       X11sock[i] -> close();
               sockset -> addReadMask(X11Serv);
               sockset -> addReadMask(Xwindow::javasock);
               }
            if ( ret < 0 ) return(ret);
            }
         }
      }
   if ( sockset -> isset(X11Serv))
      {
      if ( s < X11SESSIONS )
         {
         std::cerr << "Accept new X11 socket : " << s << std::endl;
         X11sock[s] = new tcpSocket(X11Serv -> accept());
         // Add to Read Mask
         sockset -> addReadMask(X11sock[s]);
         connectionSetup(X11sock[s]);
         s++;
         }
      else
         {
         std::cerr << "Maximum number of X11 Sessions" << std::endl;
         exit(-3);
         }
      }     
   } while ( v > 0 );
std::cerr << "Timed Out : " << v << " : " << std::strerror(errno)<< std::endl;
return(-3);
}

void sigHandler(int s)
{
std::cerr << "Signal Handler" << std::endl;
if ( Xwindow::javasock != NULL )
   {
   std::cerr << "Closing java socket" << std::endl;
   Xwindow::javasock -> close();
   }
std::cerr << "Add closing X11 sockersocket" << std::endl;
//if ( Xwindow::X11sock != NULL  )
//   {
//   std::cerr << "Closing X11 socket" << std::endl;
//   Xwindow::X11sock -> close();
//   }
std::cerr << "Exiting Program" << std::endl;
exit(3);
}

int exportDisplay(int d)
{
static char disp[42] = "DISPLAY=";
int i,ret;

std::cerr << "exportDisplay : " << d << std::endl;
i = strlen(disp);
if (gethostname(&disp[i],sizeof(disp) - 2 - i) == -1 )
   {
   std::cerr << "GetHostname Failed errno " << errno << std::endl;
   exit(2);
   }
i = strlen(disp);
disp[i++] = ':';
disp[i++] = '0' + d;
disp[i] = 0;
std::cerr << "export " << disp << std::endl;
if ( ret = ::putenv(disp) != 0 )
   std::cerr << "putenv failed errno " << errno << std::endl;
return(ret);
}

int setupServerX(int debug,int display)
{
std::cerr << "setupServerX : " << display << std::endl;
if (( Xwindow::display = ::XOpenDisplay(displayVariable)) == NULL )
   {
   std::cerr << "Failed to open display" << std::endl;
   exit(2);
   }
std::cerr << "Opening X11 server Socket" << std::endl;
X11Serv = new tcpSocket(AF_INET,SOCK_STREAM);
X11Serv -> setReUse();
//
// Will need to vary Socket for X as xclient such as info close
// stream and open new sock with X-server and also need to
// deal with more than one client
//
std::cerr << "Binding Socket : " << 6000 + display << std::endl;
if (debug) // Are we in debugging mode ?
   {
   while ( X11Serv -> bind(INADDR_ANY,6003) < 0 )
      {
      // Socket not yet free sleep and wait
      std::cerr << "Waiting for X server Socket : 6003 to free" << std::endl;
      sleep(30);
      }
   }
else
   {
   while ( X11Serv -> bind(INADDR_ANY,6000 + display) < 0 )
      {
      display++;
      }
   }
std::cerr << "Listening on X11 Server " << 6000 + display << std::endl;
X11Serv -> listen(5);
return(0);
}

int execClient(char *command)
{
// Very Very Lazy, use Semaphore
::sleep(2);               // sleep for 2 secs
// Execute command to run X client
std::cerr << "execl : " << command << std::endl;
if ( ::execlp(command,command,NULL) < 0 )
   {
   std::cerr << "Error execing application - errno < " 
        << errno << " > " << strerror(errno) << std::endl;
   return(-1);
   }
return(0);  
}

// This has been hacked/hard coded just to work
// This needs a rewrite to cope with XDMCP states and
// also processing other java client requests
void process_XDMCP(int clientAddr, int displayID)
{
typedef struct __attribute__((__packed__)) headerStr {
       CARD16 version;
       CARD16 opcode;
       CARD16 length;
       } header;

typedef struct queryRequestStr {
       CARD8  number;
       } queryRequest;

typedef struct willingResponseStr {
       char   authenticationName[8];
       char   hostName[8];
       char   status[8];
       } willingResponse;

typedef struct __attribute__((__packed__)) requestRequestStr {
       CARD16 displayID;
       CARD8  connectionTypeNum;
// Just the one type IPv4 - No IPv6
//       CARD16 connectionType[2];
       CARD16 connectionType[1];
       CARD8  connectionAddrNum;
       CARD16 addr1Len;
       CARD32 addr1;
// Just the one type IPv4 - No IPv6
//       CARD16 addr2Len;
//       CARD32 addr2[4];
       CARD16 authenticationNameLen;
       CARD16 authenticationDataLen;
       CARD8  authorizationNamesLen;
       CARD16 name1Len;
       char   name1[0x12];
       CARD16 name2Len;
       char   name2[0x13];
       CARD16 name3Len;
       char   name3[0x09];
       CARD16 manufacturersDisplayIDLen;
       } requestRequest;      

typedef struct acceptResponseStr {
       CARD32 sessionID;
       CARD16 authLen;
       char   authData[100];
       } acceptResponse;

typedef struct manageRequestStr {
       CARD32 sessionID;
       CARD16 displayID;
       CARD16 displayClassLen;
       char   displayClass[15];
       } manageRequest;

struct __attribute__((__packed__)) RequestStr {
       headerStr hdr;
       union {
             queryRequestStr queryRequest;
	     requestRequestStr requestRequest;
	     manageRequestStr manageRequest;
             } data;
      } Request;

struct __attribute__((__packed__)) ResponseStr {
       headerStr hdr;
       union {
             willingResponseStr willingResponse;
             acceptResponseStr acceptResponse;
	     } data;
      } Response;

int complete = FALSE;
int sessionID;

std::cerr << "Start XDMCP : "<< std::endl;

tcpSocket udp(AF_INET,SOCK_DGRAM);
udp.setAddress(INADDR_LOOPBACK,177);
udp.setBroadcastEnable();

Request.hdr.version = htons(1);
Request.hdr.opcode  = htons(2);
Request.hdr.length  = htons(1);;
Request.data.queryRequest.number  = 0;


udp.sendTo((char *) &Request,7);
std::cerr << "XDMCP Query Sent" << std::endl;
while ( complete == FALSE ) {
	udp.receiveFrom((char *) &Response,sizeof(Response));
	std::cerr << "XDMCP Client Opcode : "<< ntohs(Response.hdr.opcode) << std::endl;

	switch (ntohs(Response.hdr.opcode)) {
	     case 5 :    	  // Willing received 
                  std::cerr << "XDMCP Willing Received - DisplayID : "<< displayID << std::endl;
        	  Request.hdr.version = htons(1);
       		  Request.hdr.opcode  = htons(7);
//        	  Request.hdr.length  = htons(0x5b);
		  Request.hdr.length  = htons(sizeof(Request.data.requestRequest));
// DisplayID
        	  Request.data.requestRequest.displayID = htons(displayID);
// Just the one type IPv4 - No IPv6
//        	  Request.data.requestRequest.connectionTypeNum = 2;
		  Request.data.requestRequest.connectionTypeNum = 1;
        	  Request.data.requestRequest.connectionType[0] = 0;
// Just the one type IPv4 - No IPv6
//        	  Request.data.requestRequest.connectionType[1] = htons(6);
//        	  Request.data.requestRequest.connectionAddrNum = 2;
		  Request.data.requestRequest.connectionAddrNum = 1;
        	  Request.data.requestRequest.addr1Len = htons(4);
// Client Addr
        	  Request.data.requestRequest.addr1 = clientAddr;
// Just the one type IPv4 - No IPv6
//        	  Request.data.requestRequest.addr2Len = htons(16);
//		  Request.data.requestRequest.addr2[0] = 0x000080fe;
//		  Request.data.requestRequest.addr2[1] = 0x00000000;
//                Request.data.requestRequest.addr2[2] = 0x022264ff;
//		  Request.data.requestRequest.addr2[2] = 0xff642220;
//                  Request.data.requestRequest.addr2[3] = 0xfe278592;
//		  Request.data.requestRequest.addr2[3] = 0x928527fe;
        	  Request.data.requestRequest.authenticationNameLen = 0;
        	  Request.data.requestRequest.authenticationDataLen = 0;
        	  Request.data.requestRequest.authorizationNamesLen = 3;
        	  Request.data.requestRequest.name1Len = htons(0x12);
        	  ::strcpy(Request.data.requestRequest.name1,"MIT-MAGIC-COOKIE-1");
        	  Request.data.requestRequest.name2Len = htons(0x13);
        	  ::strcpy(Request.data.requestRequest.name2,"XDM-AUTHORIZATION-1");
        	  Request.data.requestRequest.name3Len = htons(0x09);
        	  ::strcpy(Request.data.requestRequest.name3,"SUN-DES-1");
        	  Request.data.requestRequest.manufacturersDisplayIDLen = 0;
		  std::cerr << "XDMCP Request sent" << std::endl;
        	  udp.sendTo((char *) &Request,sizeof(Request.hdr)+sizeof(Request.data.requestRequest));
//		  udp.sendTo((char *) &Request,0x5B);
		  std::cerr << "XDMCP Length : " << htons(Request.hdr.length) << std::endl;
        	  break;
     
     	     case 8 :  // Accept received
                  std::cerr << "XDMCP Accept Received - Session ID : " << htonl(Response.data.acceptResponse.sessionID) << std::endl;
                  sessionID = Response.data.acceptResponse.sessionID;
          	  // Send Manage
          	  Request.hdr.version = htons(1);
          	  Request.hdr.opcode  = htons(10);
          	  Request.hdr.length  = htons(0x17);;
          	  Request.data.manageRequest.sessionID = sessionID;
          	  Request.data.manageRequest.displayID = htons(displayID);
          	  Request.data.manageRequest.displayClassLen = htons(0xF);
          	  ::strcpy(Request.data.manageRequest.displayClass,"MIT-unspecified");
		  udp.sendTo((char *) &Request,sizeof(Request.hdr)+0x17);
//          	  udp.sendTo((char *) &Request,sizeof(Request.hdr)+sizeof(Request.data.manageRequest));
	          std::cerr << "XDMCP Manage Sent" << std::endl;
		  complete = TRUE;
                  break;

      	      default :
          	   std::cerr << "XDMCP Request not handled : " << ntohs(Response.hdr.opcode) << std::endl;
                   break;
              }
       }
}


int inetdProcess(int dispNum)
{
int errFlag;
int setupPid;

// Needs updating & testing
std::cerr << "Running under inetd" << std::endl;
std::cerr << "Running under inetd NOT YET UPDATED" << std::endl;
return(-1); // Abort

javaServ = new tcpSocket(0);
setupServerX((dispNum != 3),dispNum);
errFlag = 0;
std::cerr << "Forking for X11 appl" << std::endl;
if ((setupPid = ::fork()) < 0 ) // Fork and check okay
   {
   std::cerr << "Fork failed : " << errno << std::endl;
   return(-1);
   }
if ( setupPid == 0 ) // Is this the Child - Yes execl x application
   {
   execClient("xclock");
   }
else
   {
   // Need to loop on accept in case client closes stream e.g. info
   while (errFlag == 0)
      {
      std::cerr << "Accepting X11 Server" << std::endl;
      //Xwindow::X11sock  = new tcpSocket(X11Serv-> accept());
      //connectionSetup(sockPtr);
      errFlag = process();
      }
   ::kill(setupPid,SIGQUIT);
   //Xwindow::X11sock -> close();
   }
return(errFlag);
}

int listenProcess(int dispNum)
{
int       errFlag;

char	  command[120];
char      hostname[120];

std::cerr << "Opening Java server Socket" << std::endl;
javaServ = new tcpSocket(AF_INET,SOCK_STREAM);
javaServ -> setReUse();
javaServ -> getHostName(hostname,120);
javaServ -> getHostIP();

std::cerr << "Binding Socket" << std::endl;
while ( javaServ -> bind(INADDR_ANY,PORT) < 0 )
   {
   std::cerr << "Waiting on Server Socket port : "<< PORT << std::endl;
   sleep(5);
   }
std::cerr << "Listening on Java Server" << std::endl;
javaServ -> listen(5);

std::cerr << "Accepting java Server" << std::endl;
Xwindow::javasock  = new tcpSocket(javaServ-> accept());
std::cerr << "Reading required X Client Application" << std::endl;
std::memset(command,0,120);	
readCommand(command);
std::cerr << "Command Read : " << command << std::endl;
// Open X11 Server port & listen in preperation
setupServerX(True,dispNum);
if (std::strcmp(command,"XDMCP") == 0)
   {
   int client;

   // Process XDMCP which should open X11 Session
   client = javaServ -> getHostIP();
   process_XDMCP(client,dispNum);
   }
else if (std::strcmp(command,"Null") != 0)
   // We have to fork and exec X Client
   {
   std::cerr << "Forking for X Client" << std::endl;
   if ((setupPid1 = ::fork()) < 0 ) // Fork and check okay
      {
      std::cerr << "Fork failed for X Client : " << errno << std::endl;
      return(-1);
      }
   std::cerr << "Process Id : " << setupPid1 << std::endl;
   if ( setupPid1 == 0 ) // Is this the Child - Exec X Client
      {
      // Close sockets
      X11Serv -> close();
      // Close main java server socket
      javaServ -> close();
      // Close Java socket
      Xwindow::javasock -> close();
      // Export appropriate DISPLAY variable
      exportDisplay(dispNum);
      execClient(command);
      }
   }
std::cerr << "Main Forking" << std::endl;
if ((setupPid2 = ::fork()) < 0 ) // Fork and check okay
   {
   std::cerr << "Main Fork failed : " << errno << std::endl;
   return(-1);
   }
if ( setupPid2 == 0 ) // Is this the Child 
   {     
   do 
      {
      // Process Client
      errFlag = process();
      } while (errFlag == 0);
   }
else
   {
   // This is root Parent Task go back to accepting new applets
   std::cerr << std::endl << "Root Process Close socket and back to Accepting" << std::endl;
   // Close X11 Server socket if open i.e. XDCMP
   X11Serv -> close();
   // Close java client socket
   Xwindow::javasock -> close();
   }
return(0);
}

int main(int argc,char **argv)
{
int       i,dispNum,sockNum;
Font      font;
int       setupPid;
int       errFlag;

// setbuf(stdout,NULL);
setbuf(stdout,0);
::signal(SIGQUIT,sigHandler);
::signal(SIGTERM,sigHandler);
::signal(SIGINT,sigHandler);
::signal(SIGUSR1,sigHandler);

std::cerr << "JavaXServ version 1.1 alpha Copyright: Keith Sloan 1997-2015" << std::endl;
dispNum = 3;
if ( argc > 1 )
   {
   sockNum = atoi(argv[1]);
   }
if ( argc > 2 )
   {
   dispNum = atoi(argv[2]);
   }
std::cerr << " Display Number : " << dispNum << std::endl;   
if ((displayVariable = ::getenv("DISPLAY")) == 0 )
   {
   std::cerr << "DISPLAY variable Not set" << std::endl;
   exit(2);
   }
   std::cerr << "About to open display" << std::endl;
if (( Xwindow::display = ::XOpenDisplay(displayVariable)) == NULL )
   {
   std::cerr << "Failed to open display" << std::endl;
   exit(2);
   }
// Create root window ( same parameters as connection setup
rootWin = new Xwindow(-1,XDefaultRootWindow(Xwindow::display),NULL,0,0,600,800,8,1);
rootGC = new GraphicContext();
if ( ::strstr(argv[0],"ijavaServ" ) == 0 )
   {
   listenProcess(dispNum);
   }
else
   {
   inetdProcess(dispNum);
   }
return(0);
}

